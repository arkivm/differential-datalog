import d3_application
import display

input relation Fact(x:u64, k:u128)
output relation Anchor(x:u64)
relation PrintMSResult(x:u64, me:D3logLocationId)
relation MSResult(x:u64, me:D3logLocationId)
relation LocalizedFact(x:u64)
relation Schedule(node:u128, born:u64, dies:u64)
relation Dist(n:Vec<D3logLocationId>)
relation Location(n:D3logLocationId, x:u32, y:u32)
relation Line(id:u128, f:D3logLocationId, t:D3logLocationId)
relation AccMSResult(x:u64)

// rendering
Position(id, x, y)@n :- Browser(n, _), Myself(id), Location(id, x, y).
Color(id, "lightgreen")@n :- Browser(n, _), Myself(id).
Radius(id, 50)@n :-      Browser(n, _), Myself(id).
Kind(id, "circle")@n :-  Browser(n, _), Myself(id).
Border(id, "black")@n :- Browser(n, _), Myself(id).
Width(id, 3)@n :-        Browser(n, _), Myself(id).
Text(id, text)@n :-      Browser(n, _), Myself(id), var text = id.to_string().

Position(id, x,y)@n :- Browser(n, _),      Line(id, a, _), Location(a, x, y).
NextPosition(id, x,y)@n :-  Browser(n, _), Line(id, _, b), Location(b, x, y).
Kind(id, "line")@n :- Browser(n, _), Line(id, _, b).
Color(id, "black")@n :- Browser(n, _), Line(id, _, b).


// the path here should actually be an executable, or I suppose a url to one.
// but here we may be able to use the value of argv[0] to make it
// slightly less broken
Process(loc, "/Users/ehoffman/ddev/rust/template/d3log/examples/mini_skyline_ddlog/target/debug/mini_skyline_cli", true) :-
             Clock(t),
             var now = t.group_by(()).max(),
             Schedule(loc, born, dies),
             born <= now,
             dies >= now,             
             Fact(_, loc).

Schedule(1, 0, 100).
Schedule(2, 0, 15).
Schedule(3, 30, 100).
Schedule(4, 0, 100).
Schedule(6, 0, 100).

Location(1, 300, 100).
Location(2, 300, 200).
Location(3, 300, 300).
Location(4, 300, 400).

// demo cheese
Location(100, 100, 250).
Location(6, 500, 250).

Dist(ws) :-
  Process(loc, _, _),
  var ws:Vec<D3logLocationId> = loc.group_by(()).to_vec().

LocalizedFact(x)@n:-
      Fact(x, key),
      Dist(ws),
      var n = ws.nth(((key as u64) % ws.len()) as u64).unwrap_or_default().

MSResult(x, y) :- LocalizedFact(x),
                  Myself(y).

PrintMSResult(x, y)@6 :-
                   MSResult(x, y).

// if I rotate stdout to the top, there is a scoping issue?
AccMSResult(x)@n :-
      PrintMSResult(v, y),
      var x = v.group_by(()).group_sum(),
      Stdout(n).

                 

Anchor(x) :- AccMSResult(x).



